---
title: "Practica Fundamentos"
author: "Juan José, Moncef y Jose"
date: "17/12/2021"
output:
  html_document:
    theme: united
    code_folding: "hide"
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
#Librerias

library(MASS)
library(emmeans)
library(stargazer)
library(regclass)
library(car)
library(lsr)
library(gvlma)
library(nortest)
library(tidyr)
library(date)
library(zoo)
library(tidyverse)
library(ggplot2)
library(corrplot)
library(caret)
library(dplyr)
library(olsrr)
library(fastDummies)
library(pracma)
library(geosphere)
library(readxl)
library(glmnet)
library(mice)
library(missForest)
library(VIM)
library(readr)
library(naniar)
library(gridExtra)
library(grid)
library(lattice)
library(GGally)
```

## INTRODUCCIÓN

Para la realización de la práctica se ha selecionado un base de datos con los precios de viviendas del barrio King County del estado de Washington(EEUU). Base de datos descargada de: https://www.kaggle.com/swathiachath/kc-housesales-data
Para la realización del procto se emplean las siguientes librerías.

* MASS
* emmeans
* stargazer
* regclass
* car
* lsr
* nortest
* tydyr
* date
* zoo
* tidyverse
* ggplot2
* corrplot
* caret
* dplyr
* olsrr
* fastDummies
* pracma
* geosphere
* readxl
* glmnet
* mice
* missForest
* VIM
* readr
* naniar
* gridExtra
* grid
* lattice
* GGally

## OBJETIVOS

El objetivo de la práctica será la elaboracion de un informe de un proyecto de Ciencia de Datos en R Markdown. Se emplearán las técnicas aprendidas durante el curso para el estudio del dataframe seleccionado. 

### Objetivos generales

* Analisis de la variable __"price"__ como objetivo. Se realizarán transformacioes.
* Aplicar un modelo de regresión lineal para tratar de inferir la variable __"price"__ o sus posteriores transformaciones.

### Objetivos generales

1. Separación de datos en 2 grupos: train y test.
2. Realización de un análisis exploratorio inicial del dataframe.
3. Detección e imputación de datos faltantes.
4. Transformación de varaibles de interés.
5. Aplicar un modelo de regresión lineal válido la predición de la variable precio de venta.

## CARGA DE DATOS

Lectura de datos, separación TRAIN vs TEST

```{r}
#Cargamos los datos y definimos una muestra train y otra test

train <- as.data.frame(read.csv(file = 'C:/Users/Juanjo/Desktop/MONCEF/house_king_county-Moncef/train.csv'))

```

Descripción de variables

* id: valor único
* date: fecha de venta de la vivienda
* price: precio de venta
* bedrooms: número de habitaciones por vivienda
* bathrooms: número de baños por vivienda
* sqft_living: superficie de la vivienda en pies cuadrados
* sqft_lot: superficie de la parcela de la vivienda en pies cuadrados
* floors: número de plantas por vivienda.
* waterfront: si la vivienda tiene vistas al mar
* view: numero visita a la vivienda
* condition: el estado de la vivienda establecido mediante una variable numérica del
* grade: nota general de la vivienda propuesta por el sistema de puntuación de la zona
* sqft_above: superficie de la huella perimetral de la vivienda sobre rasante en pies cuadrados.
* sqft_basement: superficie de la vivienda bajo rasante en piés cuadrados
* yr_built: año de construcción de la vivienda
* yr_renovated: año de la renovación de la vivienda
* zipcode: codigo postal de la vivienda
* lat: latitud de la coordenada de la vivienda medida en pies
* long: longitud de la coordenada de la vivienda medida en pies
* sqft_living15: superficie de la vivienda en el año 2015 
* sqft_lot15: superficie de la parcela en el año 2015 

## ANÁLISIS EDA

Se realiza un análisis exploratorio inicial para observar las varaibles.


### Analisis de datos actuales

__Datos actuales__

```{r}
str(train)
```

### Variables cuantitativas

```{r}
var_cuant <- train[, c("price", "sqft_living", "sqft_living15", "sqft_lot", "sqft_lot15", "sqft_above", "sqft_basement", "yr_built", "yr_renovated")]
str(var_cuant)
```


Se estudia la variable __precio__
```{r}
p1 <- ggplot(train, aes(x=price)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=price), colour = "navy", fill = "steelblue")
grid.arrange(p1, p2, nrow=1)
summary(train$price)
```

Se estudia la variable __sqft_living__
```{r}
p3 <- ggplot(train, aes(x=sqft_living)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p4 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_living), colour = "navy", fill = "steelblue")
grid.arrange(p3, p4, nrow=1)
summary(train$sqft_living)
```


Se estudia la variable __sqft_living15__
```{r}
p5 <- ggplot(train, aes(x=sqft_living15)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p6 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_living15), colour = "navy", fill = "steelblue")
grid.arrange(p5, p6, nrow=1)
summary(train$sqft_living15)
```

Se estudia la variable __sqft_lot__
```{r}
p7 <- ggplot(train, aes(x=sqft_lot)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) 
p8 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_lot), colour = "navy", fill = "steelblue")
grid.arrange(p7, p8, nrow=1)
summary(train$sqft_lot)
```

Se estudia la variable __sqft_lot15__
```{r}
p9 <- ggplot(train, aes(x=sqft_lot15)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
p10 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_lot15), colour = "navy", fill = "steelblue")
grid.arrange(p9, p10, nrow=1)
summary(train$sqft_lot15)
```


Se estudia la variable __sqft_above__
```{r}
p11 <- ggplot(train, aes(x=sqft_above)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p12 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_above), colour = "navy", fill = "steelblue")
grid.arrange(p11, p12, nrow=1)
summary(train$sqft_above)
```


Se estudia la variable __sqft_basement__
```{r}
p13 <- ggplot(train, aes(x=sqft_basement)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
p14 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=sqft_basement), colour = "navy", fill = "steelblue")
grid.arrange(p13, p14, nrow=1)
summary(train$sqft_basement)
```


Se estudia la variable __yr_built__
```{r}
p15 <- ggplot(train, aes(x=yr_built)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
p16 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=yr_built), colour = "navy", fill = "steelblue")
grid.arrange(p15, p16, nrow=1)
summary(train$yr_built)
```

Se estudia la variable __yr_renovated__
```{r}
p17 <- ggplot(train, aes(x=yr_renovated)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
p18 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=yr_renovated), colour = "navy", fill = "steelblue")
grid.arrange(p17, p18, nrow=1)
summary(train$yr_renovated)
```



### Variables cualitativas

```{r}
var_cual <- train[, c("date", "bedrooms", "bathrooms", "floors", "waterfront" , "view" , "condition", "grade", "zipcode")]
str(var_cual)
```

Se estudia la variable __date__
```{r}
dtdate <- gsub("T000000","",as.character(train$date))
dtdate <- as.data.frame(dtdate)
dtdate <- as.Date(dtdate[, 'dtdate'],'%Y%m%d')
str(dtdate)

Month <- format(dtdate,"%m")
Year <- format(dtdate,"%Y")
df_dateMix <- data.frame(Month, Year)
df_date2014 <- subset(df_dateMix, Year == 2014)
df_date2015 <- subset(df_dateMix, Year == 2015)
p1 <- ggplot(df_dateMix, aes(x=Year)) + geom_bar(colour = "navy", fill = "steelblue") + ggtitle("Years")
p2 <- ggplot(df_date2014, aes(x=Month)) + geom_bar(colour = "navy", fill = "steelblue") + ggtitle("2014 Months")
p3 <- ggplot(df_date2015, aes(x=Month)) + geom_bar(colour = "navy", fill = "steelblue") + ggtitle("2015 Months")

grid.arrange(p1, p2, p3, nrow=1)
summary(dtdate)
```
Se estudian las variable __bedrooms, bathrooms, floors__
```{r}
p1 <- ggplot(train, aes(x=bedrooms)) + geom_bar(colour = "navy", fill = "steelblue")
p2 <- ggplot(train, aes(x=bathrooms)) + geom_bar(colour = "navy", fill = "steelblue")
p3 <- ggplot(train, aes(x=floors)) + geom_bar(colour = "navy", fill = "steelblue")

grid.arrange(p1, p2, p3, nrow=1)
summary(train$bedrooms)
summary(train$bathrooms)
summary(train$floors)
```

Se estudian las variable __waterfront, view__
```{r}
p1 <- ggplot(train, aes(x=waterfront)) + geom_bar(colour = "navy", fill = "steelblue")
p2 <- ggplot(train, aes(x=view)) + geom_bar(colour = "navy", fill = "steelblue")

grid.arrange(p1, p2, nrow=1)
summary(train$waterfront)
summary(train$view)
```

Se estudian las variable __condition, grade__
```{r}
p1 <- ggplot(train, aes(x=condition)) + geom_bar(colour = "navy", fill = "steelblue")
p2 <- ggplot(train, aes(x=grade)) + geom_bar(colour = "navy", fill = "steelblue")

grid.arrange(p1, p2, nrow=1)
summary(train$condition)
summary(train$grade)
```

Se estudia la variable __zipcode__
```{r}
ggplot(train, aes(x=zipcode)) + geom_bar(colour = "navy", fill = "steelblue")
summary(train$zipcode)
```


### Creación de nuevas variables

__Variables__

Una vez estudiadas las variables, se crean variables en base a __price y date__ extrayendo el __año, mes, trimestre, antigüedad, años desde la renovación, y el precio por metro cuadrado.__


```{r}
train$sale_date = substr(train$date, 1, 8)
train = transform(train, sale_date = as.Date(as.character(sale_date), "%Y%m%d"))
train$sale_year = as.numeric(format(train$sale_date, format="%Y"))
train$sale_month = format(train$sale_date, format="%m")
train$sale_quarter = as.yearqtr(train$sale_date)
train$sale_quarter = str_sub(train$sale_quarter,-2,-1)
train$sale_tenure =  as.numeric(train$sale_year) - train$yr_built
train$yr_since_last_renovated = ifelse(train$sale_year - train$yr_renovated > 2013, 0, train$sale_year - train$yr_renovated)
train$price_m2 = train$price/train$sqft_living
str(train)
```

Se estudian las variable __sale_year, sale_month, sale_quarter__
```{r}
p1 <- ggplot(train, aes(x=sale_year)) + geom_bar(colour = "navy", fill = "steelblue")
p2 <- ggplot(train, aes(x=sale_month)) + geom_bar(colour = "navy", fill = "steelblue")
p3 <- ggplot(train, aes(x=sale_quarter)) + geom_bar(colour = "navy", fill = "steelblue")

grid.arrange(p1, p2, p3, nrow=1)
summary(train$sale_year)
summary(train$sale_month)
summary(train$sale_quarter)
```

Se estudian las variable __sale_tenure, yr_since_last_renovated2__
```{r}
p1 <- ggplot(train, aes(x=sale_tenure)) + geom_bar(colour = "navy", fill = "steelblue")
p2 <- ggplot(train, aes(x=yr_since_last_renovated)) + geom_bar(colour = "navy", fill = "steelblue")
grid.arrange(p1, p2, nrow=1)
summary(train$sale_tenure)
summary(train$yr_since_last_renovated)
```

Se estudian las variable __price_m2__
```{r}

p3 <- ggplot(train, aes(x=price_m2)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p4 <- ggplot(train, aes(x=1)) + geom_boxplot(aes(y=price_m2), colour = "navy", fill = "steelblue")

grid.arrange(p3, p4, nrow=1)
summary(train$price_m2)
```



### Analisis multivariante cuantitativo

Se estudia la correlación entre las variables __sqft_living"__, __"sqft_lot"__, __"sqft_living15"__, __"sqft_basement"__, __"sqft_above"__, __"price"__, __"price_m2"__, __"Dist_from_seattle"__, __"Sale_tenure"__ y __"yr_built"__.
```{r}
am_cuant <- train %>% select("price","Dist_from_seattle","price_m2", "sqft_living","sqft_lot", "sqft_above", "sqft_basement", "yr_built", "yr_renovated", "sqft_living15", "sqft_lot15","sale_tenure")

amc1 <- c("sqft_living", "sqft_lot", "sqft_living15", "sqft_basement", "sqft_above","price","price_m2","Dist_from_seattle","sale_tenure","yr_built")
amc2 <- c("yr_built", "yr_renovated", "price")



#Correlación numérica entre variables
corr <- am_cuant %>% na.omit() %>% cor()

#Correlaciones importantes
as.data.frame(as.table(corr)) %>% subset(., abs(Freq) > 0.4) %>% subset(., abs(Freq) != 1) %>% .[order(.$Freq, decreasing = TRUE),] %>%
  .[c(seq(1, nrow(.), by=2)),]
```
Se puede observar que las variables con mayor correlación son:
__"sqft_above"__ y __"sqft_living"__ . Probable relación lineal.
__"sqft_living15"__ y __"sqft_linving"__. Se debe a que es la misma variable actualizada.No se podrán usar ambas en el modelo final.
__"sqft_lot15" y "sqft_lot"__. Misma variable actualizada. No se podrán usar ambas en el modelo final.
_"sqft_living" y "price"__.
__"sqft_above" y "price"__.
__"sqft_living15 y "price"__.
__"price_m2"__ y __"price"__. 
__"yr_built"__ y __"sqft_above"__. 


```{r}
am_cuant1 <- am_cuant %>% select(amc1) %>% na.omit() %>% ggcorr()
grid.arrange(am_cuant1, nrow=1)
```
De igual forma en el anterior grafico encontramos las mismas correlaciones entre variables.


Relación entre la variable __"sqft_above" y "sqft_living"__.
```{r}
ggplot(train,aes(x=sqft_above,y=sqft_living))+geom_point(alpha=0.5)+geom_smooth()+scale_x_continuous(limits = c(0, 6500))
```
Existencia de combinación lineal entre ambas variables.

Relación entre  __"sqft_living"__ y __"sqft_living15"__.
```{r}
ggplot(train,aes(x=sqft_living,y=sqft_living15))+geom_point(alpha=0.5)+geom_smooth()+scale_x_continuous(limits = c(0, 6000))+geom_abline(intercept=0,color="red")
```
Línea roja representa las casas en las que no hubo reforma. Por encima de ella las casa amplia su terreno habitable y por debajo la disimnuye tras la reforma.Se trata de una correlación lineal.

Relación entre  __"sqft_lot"__ y __"sqft_lot15"__.
```{r}
ggplot(train,aes(x=sqft_lot,y=sqft_lot15))+geom_point(alpha=0.5)+geom_smooth()+scale_x_continuous(limits = c(0, 6000))
```
Combinación lineal entre variables.

Relación entre __"

Relación entre __"Dist_from_seattle" y "price"__.
```{r}
a <- ggplot(train,aes(x=Dist_from_seattle,y=price))+geom_point()+geom_smooth()+scale_x_continuous(limits = c(0, 60000))
b <- ggplot(train,aes(x=Dist_from_seattle,y=price_m2))+geom_point()+geom_smooth()+scale_x_continuous(limits = c(0, 60000))
grid.arrange(a,b, nrow=1)
```
Combinación con __"price_m2"__ explica más la relación.

Mapa de calor de la variable __"price_m2"__
```{r}
ggplot(train, aes(x=long, y=lat, color=price_m2)) + geom_point(alpha=.2)+ xlim(-122.5, -121.75) + ylim(47.3, 47.75)  + ggtitle("Precio m2")

```

Mapa de calor de la variable __"yr_built"__
```{r}
ggplot(train, aes(x=long, y=lat, color=yr_built)) + geom_point(alpha=.2)+ xlim(-122.5, -121.75) + ylim(47.3, 47.75)  + ggtitle("Precio m2")

```

Relación entre __"yr_built" y "Dist_from_seattle"__.
```{r}
ggplot(train,aes(x=yr_built,y=Dist_from_seattle))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(1900, 2000))+geom_smooth()

```

Relación entre las varaibles __"sqft_above" y "price"__ y __"sqft_living15" y "price"__
```{r}
a <- ggplot(train,aes(x=sqft_above,y=price))+geom_point(alpha=0.5)+geom_smooth()+scale_x_continuous(limits = c(0, 6000))+scale_y_continuous(limits = c(0, 4e6))
b <- ggplot(train,aes(x=sqft_living15,y=price))+geom_point(alpha=0.5)+geom_smooth()+scale_x_continuous(limits = c(0, 4500))+scale_y_continuous(limits = c(0, 4e6))
grid.arrange(a,b)
```
Relación entre las variable __"sqft_above" y "price_m2"__ y __"sqft_living15" y "price_m2"_
```{r}
a <- ggplot(train,aes(x=sqft_above,y=price_m2))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(0, 6000))
b <- ggplot(train,aes(x=sqft_living15,y=price_m2))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(0, 6000))
grid.arrange(a,b)
```
En este caso __"price"__ explica mejor la relación.

Relación entre __"log(price)" y "sqft_above" y "sqft_living15"__.

```{r}
a <- ggplot(train,aes(x=sqft_above,y=log(price)))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(0, 6000))+geom_smooth()
b <- ggplot(train,aes(x=sqft_living15,y=log(price)))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(0, 6000))+geom_smooth()
grid.arrange(a,b)
```

Relación entre __"yr_built" y "sqft_above"__
```{r}
ggplot(train,aes(x=yr_built,y=sqft_above))+geom_point(alpha=0.5)+scale_x_continuous(limits = c(1900, 2020))+geom_smooth()

```


### Analisis multivariante cualitativo

Se estudian las correlaciones entre las variables cualitativas _"bedrooms", "bathrooms","condition", "grade", "sale_tenure", "floors", "price" y "price_m2"__.
```{r}
am_cual <- train %>% select("date","sale_date", "sale_year", "sale_month", "bedrooms", "bathrooms", "waterfront", "view", "condition", "grade", "zipcode","lat", "long","price","price_m2","floors","sale_tenure")
am1 <- c("bedrooms", "bathrooms","floors","condition","grade","price","price_m2","sale_tenure")

#Correlación numérica entre variables
corr <- am_cual %>% select(am1) %>% na.omit() %>% cor()

#Correlaciones importantes
as.data.frame(as.table(corr)) %>% subset(., abs(Freq) > 0.4) %>% subset(., abs(Freq) != 1) %>% .[order(.$Freq, decreasing = TRUE),] %>%
  .[c(seq(1, nrow(.), by=2)),]

```


```{r}
am_cual1 <- am_cual %>% select(am1) %>% na.omit() %>% ggcorr()
grid.arrange(am_cual1, nrow=1)
```

Relación entre la variable __"grade", "price" y "price_m2"__.
```{r}
a <- ggplot(train,aes(x=grade,y=price))+geom_point()+geom_smooth()
b <- ggplot(train,aes(x=grade,y=price_m2))+geom_point()+geom_smooth()
grid.arrange(a,b)
```

Relación entre __"bathrooms"__ y __"grade"__
```{r}
ggplot(train,aes(x=bathrooms,y=grade))+geom_point()+geom_smooth()+scale_x_continuous(limits=c(1,6))
```
Relación entre __"bedrooms"__ y __"grade"__
```{r}
ggplot(train,aes(x=bedrooms,y=grade,))+geom_point()+geom_smooth()+scale_x_continuous(limits=c(1,10))

```

Relación entre __"bedrooms"__ y __"bathrooms"__
```{r}
ggplot(train,aes(x=bedrooms,y=bathrooms))+geom_point()+scale_x_continuous(limits=c(1,7))
```

Relación entre la variable __"floors", "bedrooms" y "bathrooms"__.
```{r}
a <- ggplot(train,aes(x=floors,y=bedrooms))+geom_point()+geom_smooth()
b <- ggplot(train,aes(x=floors,y=bathrooms))+geom_point()+geom_smooth()
grid.arrange(a,b)
```

Relación entre __"sale_tenure"__ y __"grade"__
```{r}
ggplot(train,aes(x=sale_tenure,y=grade,))+geom_point()+geom_smooth()+scale_x_continuous(limits=c(1,120))

```
Relación entre __"bedrooms"__ y __"sale_tenure"__
```{r}
ggplot(train,aes(x=bathrooms,y=sale_tenure,))+geom_point()+geom_smooth()+scale_x_continuous(limits=c(1,5))

```

## DETECCIÓN E IMPUTACIÓN DE DATOS FALTANTES

Se realiza un análisis de la existencia de datos faltantes.

### Datos faltantes

Se analiza si existen datos faltantes.
```{r}
sum(is.na(train))
```

Se genera un 5% de datos faltantes en las variables __"grade", "sqft_living15" y "sqft_basement"__.
```{r}
miss <- c("grade", "sqft_living15","sqft_basement")
train_na <- train %>% select(miss)
train_miss <- prodNA(train_na, 0.05)

var <- c("lat", "long", "id", "date", "price","bedrooms","bathrooms","sqft_living","sqft_lot", "floors","view","waterfront", "condition","sqft_above","sqft_lot15","yr_built","yr_renovated","zipcode","sale_date","sale_year","sale_month","sale_quarter","sale_tenure","yr_since_last_renovated","price_m2","Dist_from_seattle")

train_new <- train %>% select(var)

train_miss_new <- cbind(train_miss,train_new)
colSums(is.na(train_miss_new[,miss]))
```

Análisis del patron de datos faltantes.
```{r}
mice_plot <- aggr(train_miss_new, col=c('navyblue','yellow'),
                    numbers=TRUE, sortVars=TRUE,
                    labels=names(train_miss_new), cex.axis=.7,
                    gap=1, ylab=c("Missing data","Pattern"))
```
### Imputación de datos faltantes

Para la imputación de datos se emplea el método __kNN__ a menudo denominado "imputación del vecino más cercano" que a demostrado ser eficaz. Para la imputación de una nueva observación esta es votada entre sus K vecinos más cercanos. 
```{r}
imputed <- train_miss_new %>% select(grade, bathrooms, bedrooms,price) %>% VIM::kNN(variable='grade')
imputed <- train_miss_new %>% select(sqft_basement, sqft_living, sqft_above,bedrooms, bathrooms,price) %>% VIM::kNN(variable='sqft_basement')
imputed <- train_miss_new %>% select(sqft_living15, sqft_living, sqft_above, bathrooms, bedrooms, price) %>% VIM::kNN(variable='sqft_living15')


train_miss_new$grade <- imputed$grade
train_miss_new$sqft_basement <- imputed$sqft_basement
train_miss_new$sqft_living15 <- imputed$sqft_living15

head(train_miss_new)
```



Nº filas coinciden sqft_living y sqft_above
```{r}
sqft_compare <- train[, c("sqft_living", "sqft_above")]
nrow(subset(sqft_compare, sqft_living == sqft_above))
```

## TRANSFORMACIÓN DE VARIABLES


```{r}

#Creamos dataframe que incluya las variables sin modificar y transformadas

trans_var <- train

```

### Transformaciones

Transformacion de __price__ con __log10__
```{r}

#Transformacion price con log10

price_trans <- log10(trans_var$price)
trans_var <- mutate(train, price_trans)

p1 <- ggplot(trans_var, aes(x=price)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=price_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$price)
qqline(trans_var$price)
qqnorm(trans_var$price_trans)
qqline(trans_var$price_trans)

```

Transformacion de __bedrooms__ a __dummie__, factor, y quitamos el 33
```{r}

#Transformacion bedrooms a dummie, factor, y quitamos el 33

trans_var$bedrooms= as.factor(trans_var$bedrooms)
df_bedrooms <- trans_var[, c("price", "bedrooms")]
df_bedrooms <- subset(df_bedrooms, bedrooms != 33)
#ggplot(df_bedrooms, aes(x=price, color=bedrooms, fill=bedrooms)) + geom_density(alpha=.2)
ggplot(df_bedrooms, aes(x=bedrooms, y=price, fill=bedrooms)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

trans_var$bedrooms= as.numeric(trans_var$bedrooms)
trans_var$bedrooms <- cut(trans_var$bedrooms, breaks = c(0, 4, 7, Inf), labels = c("0-3", "4-6", "+7"), right = FALSE)
df_bedrooms <- trans_var[, c("price", "bedrooms")]
ggplot(df_bedrooms, aes(x=bedrooms, y=price, fill=bedrooms)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)


```

Transformacion de __bathrooms__ a __dummie__, factor, y redondeamos hacia arriba
```{r}

#Transformacion bathrooms, redondeamos arriba y transformamos a factor

df_bathrooms <- trans_var[, c("price", "bathrooms")]
df_bathrooms$bathrooms <- ceiling(df_bathrooms$bathrooms)
trans_var$bathrooms= as.factor(df_bathrooms$bathrooms)
df_bathrooms$bathrooms= as.factor(df_bathrooms$bathrooms)
#ggplot(df_bathrooms, aes(x=price, color=bathrooms, fill=bathrooms)) + geom_density(alpha=.2) + xlim(0,1000000)
ggplot(df_bathrooms, aes(x=bathrooms, y=price, fill=bathrooms)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none")

trans_var$bathrooms= as.numeric(trans_var$bathrooms)
trans_var$bathrooms <- cut(trans_var$bathrooms, breaks = c(0, 3, 5, Inf), labels = c("0-2", "3-4", "+5"), right = FALSE)
df_bathrooms <- trans_var[, c("price", "bathrooms")]
ggplot(df_bathrooms, aes(x=bathrooms, y=price, fill=bathrooms)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,2000000)

```

Transformacion de __sqft_living__ con __log10__
```{r}

#Transformacion sqft_living con log10

sqft_living_trans <- log10(trans_var$sqft_living)
trans_var <- mutate(train, sqft_living_trans)

p1 <- ggplot(trans_var, aes(x=sqft_living)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=sqft_living_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$sqft_living)
qqline(trans_var$sqft_living)
qqnorm(trans_var$sqft_living_trans)
qqline(trans_var$sqft_living_trans)

```

Transformacion de __sqft_lot__ con __log10__
```{r}

#Transformacion sqft_lot con log10

sqft_lot_trans <- log10(trans_var$sqft_lot)
trans_var <- mutate(train, sqft_lot_trans)

p1 <- ggplot(trans_var, aes(x=sqft_lot)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
p2 <- ggplot(trans_var, aes(x=sqft_lot_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$sqft_lot)
qqline(trans_var$sqft_lot)
qqnorm(trans_var$sqft_lot_trans)
qqline(trans_var$sqft_lot_trans)

```

Transformacion de __floors__ a __dummie__, factor, y redondeamos hacia arriba
```{r}

#Transformacion floors, redondeamos arriba y transformamos a factor

df_floors <- trans_var[, c("price", "floors")]
df_floors$floors <- ceiling(df_floors$floors)
trans_var$floors= as.factor(df_floors$floors)
df_floors$floors= as.factor(df_floors$floors)
#ggplot(df_floors, aes(x=price, color=floors, fill=floors)) + geom_density(alpha=.2)
ggplot(df_floors, aes(x=floors, y=price, fill=floors)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

trans_var$floors= as.numeric(trans_var$floors)
trans_var$floors <- cut(trans_var$floors, breaks = c(0, 3, Inf), labels = c("1-2", "+3"), right = FALSE)
df_floors <- trans_var[, c("price", "floors")]
ggplot(df_floors, aes(x=floors, y=price, fill=floors)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

```

Transformacion de __waterfront__ a __dummie__ logical
```{r}

#Transformacion waterfront a dummie, logical

trans_var$waterfront = as.logical(trans_var$waterfront)
df_waterfront <- trans_var[, c("price", "waterfront")]
ggplot(df_waterfront, aes(x=price, color=waterfront, fill=waterfront)) + geom_density(alpha=.2)
ggplot(df_waterfront, aes(x=waterfront, y=price, fill=waterfront)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none")

```

Transformacion de __view__ a __dummie__ factor
```{r}

#Transformacion view a dummie, factor

trans_var$view= as.factor(trans_var$view)
df_view <- trans_var[, c("price", "view")]
ggplot(df_view, aes(x=price, color=view, fill=view)) + geom_density(alpha=.2) + xlim(0,3000000)
ggplot(df_view, aes(x=view, y=price, fill=view)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,2000000)

```

Transformacion de __condition__ a __dummie__ factor
```{r}

#Transformacion condition a dummie, factor

trans_var$condition= as.factor(trans_var$condition)
df_condition <- trans_var[, c("price", "condition")]
#ggplot(df_condition, aes(x=price, color=condition, fill=condition)) + geom_density(alpha=.2)
ggplot(df_condition, aes(x=condition, y=price, fill=condition)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

trans_var$condition= as.numeric(trans_var$condition)
trans_var$condition <- cut(trans_var$condition, breaks = c(0, 3, 5, Inf), labels = c("1-2", "3-4", "+5"), right = FALSE)
df_condition <- trans_var[, c("price", "condition")]
ggplot(df_condition, aes(x=condition, y=price, fill=condition)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

```

Transformacion de __grade__ a __dummie__ factor
```{r}

#Transformacion grade a dummie, factor

trans_var$grade= as.factor(trans_var$grade)
df_grade <- trans_var[, c("price", "grade")]
#ggplot(df_grade, aes(x=price, color=grade, fill=grade)) + geom_density(alpha=.2)
ggplot(df_grade, aes(x=grade, y=price, fill=grade)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none")+ ylim(0,1000000)

trans_var$grade= as.numeric(trans_var$grade)
trans_var$grade <- cut(trans_var$grade, breaks = c(0, 4, 5, 6, 7, 8, 9, 10, Inf), labels = c("1-3", "4", "5","6","7","8","9","+10"), right = FALSE)
df_grade <- trans_var[, c("price", "grade")]
ggplot(df_grade, aes(x=grade, y=price, fill=grade)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") + ylim(0,1000000)

```

Transformacion de __sqft_above__ con __log10__
```{r}

#Transformacion sqft_above con log10

sqft_above_trans <- log10(trans_var$sqft_above)
trans_var <- mutate(train, sqft_above_trans)

p1 <- ggplot(trans_var, aes(x=sqft_above)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=sqft_above_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$sqft_above)
qqline(trans_var$sqft_above)
qqnorm(trans_var$sqft_above_trans)
qqline(trans_var$sqft_above_trans)

```

Transformacion de __sqft_basement__ a __dummie__ logical
```{r}

#Transformacion sqft_basement a dummie, logical

sqft_basement_trans <- cut(trans_var$sqft_basement, breaks = c(-1, 1, Inf), labels = c("0", "1"), right = FALSE)
trans_var <- mutate(train, sqft_basement_trans)
trans_var$sqft_basement_trans= as.integer(trans_var$sqft_basement_trans)
trans_var$sqft_basement_trans= as.integer(trans_var$sqft_basement_trans-1)
trans_var$sqft_basement_trans= as.logical(trans_var$sqft_basement_trans)
df_sqft_basement_trans <- trans_var[, c("price", "sqft_basement_trans")]
#ggplot(df_sqft_basement_trans, aes(x=price, color=sqft_basement_trans, fill=sqft_basement_trans)) + geom_density(alpha=.2)
ggplot(df_sqft_basement_trans, aes(x=sqft_basement_trans, y=price, fill=sqft_basement_trans)) +  geom_boxplot(alpha=0.3) +  theme(legend.position="none") +ylim(0,1000000)

```

Transformacion de __zipcode__ a __dummie__ factor
```{r}

#Transformacion zipcode a dummie, factor

trans_var$zipcode= as.factor(trans_var$zipcode)
df_zipcode <- trans_var[, c("price", "zipcode")]
#ggplot(df_zipcode, aes(x=price, color=zipcode, fill=zipcode)) + geom_density(alpha=.2)
ggplot(df_zipcode, aes(x=zipcode, y=price, fill=zipcode)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") +ylim(0,3000000)

```

Transformacion de __sale_quarter__ a __dummie__ factor
```{r}

#Transformacion sale_quarter a dummie, factor

trans_var$sale_quarter= as.factor(trans_var$sale_quarter)
df_sale_quarter <- trans_var[, c("price", "sale_quarter")]
#ggplot(df_sale_quarter, aes(x=price, color=sale_quarter, fill=sale_quarter)) + geom_density(alpha=.2)
ggplot(df_sale_quarter, aes(x=sale_quarter, y=price, fill=sale_quarter)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") +ylim(0,1000000)

```

Transformacion de __Clusters__ a __dummie__ factor
```{r}

#Transformacion Clusters a dummie, factor

trans_var$Clusters= as.factor(trans_var$Clusters)
df_Clusters <- trans_var[, c("price", "Clusters")]
#ggplot(df_Clusters, aes(x=price, color=Clusters, fill=Clusters)) + geom_density(alpha=.2)
ggplot(df_Clusters, aes(x=Clusters, y=price, fill=Clusters)) +  geom_boxplot(alpha=0.3) + theme(legend.position="none") +ylim(0,1000000)
ggplot(trans_var, aes(x=long, y=lat, color=Clusters)) + geom_point(alpha=.2)+ xlim(-122.5, -121.75) + ylim(47.3, 47.75)  + ggtitle("Clusters")
```



Transformacion de __sale_tenure__ con __log10__
```{r}

#Transformacion sale_tenure con log10

sale_tenure_trans <- log10(trans_var$sale_tenure)
trans_var <- mutate(train, sale_tenure_trans)

p1 <- ggplot(trans_var, aes(x=sale_tenure)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=sale_tenure_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)  +xlim(0.7,2.1)
grid.arrange(p1, p2, nrow=1)

```

Transformacion de __Dist_from_seattle__ con __log10__
```{r}

#Transformacion Dist_from_seattle con log10

Dist_from_seattle_trans <- log(trans_var$Dist_from_seattle)
trans_var <- mutate(train, Dist_from_seattle_trans)

p1 <- ggplot(trans_var, aes(x=Dist_from_seattle)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=Dist_from_seattle_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$Dist_from_seattle)
qqline(trans_var$Dist_from_seattle)
qqnorm(trans_var$Dist_from_seattle_trans)
qqline(trans_var$Dist_from_seattle_trans)


```

Transformacion de __price_m2__ con __log10__
```{r}

#Transformacion price_m2 con log10

price_m2_trans <- log10(trans_var$price_m2)
trans_var <- mutate(train, price_m2_trans)

p1 <- ggplot(trans_var, aes(x=price_m2)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
p2 <- ggplot(trans_var, aes(x=price_m2_trans)) + geom_histogram(aes(y=..density..), colour = "navy", fill = "steelblue", bins=30) + geom_density(colour = "goldenrod1", size = 1)
grid.arrange(p1, p2, nrow=1)

qqnorm(trans_var$price_m2)
qqline(trans_var$price_m2)
qqnorm(trans_var$price_m2_trans)
qqline(trans_var$price_m2_trans)

```


### Resumen Transformaciones

* Transformacion de __price__ con __log10__
* Transformacion de __bedrooms__ a __dummie__, factor, y quitamos el 33
* Transformacion de __bathrooms__ a __dummie__, factor, y redondeamos hacia arriba
* Transformacion de __sqft_living__ con __log10__
* Transformacion de __sqft_lot__ con __log10__
* Transformacion de __floors__ a __dummie__, factor, y redondeamos hacia arriba
* Transformacion de __waterfront__ a __dummie__ logical
* Transformacion de __view__ a __dummie__ factor
* Transformacion de __condition__ a __dummie__ factor
* Transformacion de __grade__ a __dummie__ factor
* Transformacion de __sqft_above__ con __log10__
* Transformacion de __sqft_basement__ a __dummie__ logical
* Transformacion de __zipcode__ a __dummie__ factor
* Transformacion de __sale_quarter__ a __dummie__ factor
* Transformacion de __Clusters__ a __dummie__ factor
* Transformacion de __sale_tenure__ con __log10__
* Transformacion de __Dist_from_seattle__ con __log10__
* Transformacion de __price_m2__ con __log10__



```{r}

#Tranfomación de variables

train$waterfront = as.factor(train$waterfront)
train$view = as.factor(train$view)
train$zipcode = as.factor(train$zipcode)


#Creamos una variable que mide la distnacia de cada casa a la venta con respecto al centro ecónomico de la ciudad: Seattle
seattle = c(-122.335167, 47.608013)
train = mutate(train, Dist_from_seattle=distHaversine(cbind(long, lat),seattle))

#POr otro lado, se calcula la distancia de cada casa con respecto al resto, agrupando después casas cercanas en clústers.
long= train$long
lat = train$lat
DataMat<-as.matrix(cbind(long, lat))
DataMat[is.na(DataMat)]<-0

my_data <- as_tibble(DataMat)
#my_data=my_data %>% slice(1:100)
my_data = as.data.frame(my_data)

#<-distm(my_data,my_data,fun=distHaversine)/1000
#hclustfunc <- function(x) hclust(x, method="complete")
#distfunc <- function(x) as.dist((1-cor(t(x)))/2)
#d <- distfunc(Dist_Mat)
#fit <- hclustfunc(d)
#my_data$Clusters<- cutree(fit, h=0.25)
#train = merge(x = train, y = my_data, by = c("lat", "long") , all.x = TRUE)
#train$Clusters = as.factor(train$Clusters)
#bwplot(Clusters~price, data = train, horizontal= TRUE)




#specify_decimal
specify_decimal <- function(x, k) format(round(x, k), nsmall=k)

#beautifying summary.lm
new_summary  <- function(lmcoef, digits) {
  
  coefs <- as.data.frame(lmcoef)
  coefs[] <- lapply(coefs, function(x) specify_decimal(x, digits))
  coefs
  
}


#(train, file = "C:/Users/Moncef/Documents/house_king_county/train.csv")

#Convertimos las variables catageoricas en dummies para su uso en el modelo.

# train_v1<- dummy_cols(train, select_columns = c('waterfront','view','Clusters','sale_quarter'),remove_most_frequent_dummy = TRUE,
#                    remove_selected_columns = TRUE)
# 
# train_v1$sqft_lot_log = log(train_v1$sqft_lot)
# train_v1$sqft_above_log = log(train_v1$sqft_above)
# train_v1$sqft_living_log = log(train_v1$sqft_living)
# train_v1$Dist_from_seattle_log = log(train_v1$Dist_from_seattle)
# #train_v1$yr_renovated_log = log(train_v1$yr_renovated)
# #train_v1$sale_tenure_log = log(train_v1$sale_tenure)
# 
# 
# #Incluimos en c() las variables que NO queremos usar en la regresión.
# train_v2 = dplyr::select(train_v1,-c(id,sale_tenure,yr_renovated,sqft_above,sqft_lot,sale_tenure,yr_renovated,sqft_living,Dist_from_seattle,price,date,zipcode,sqft_basement,lat,sqft_lot15,long,date,sale_date,
#                               sale_year,yr_built,sale_month,yr_since_last_renovated,sqft_living15))
# 
# summarize(train_v2)
# 
# model <- lm(log(price_m2) ~ ., data = train_v2)
# summary(model)
# new_summary(summary(model)$coefficients, 5)
# 
# plot(model, 1)
# res <- resid(model)
# plot(fitted(model), res)
# plot(model, which=1, col=c("blue"))
# plot(model, 2)
# 
# require(nortest)  # Se debe haber instalado nortest
# lillie.test(model$residuals)


```


## ANÁLISIS DEL MODELO

```{r, include=FALSE}
train <- as.data.frame(read.csv(file = 'C:/Users/Juanjo/Desktop/MONCEF/house_king_county-Moncef/train_final.csv'))

test_final <- as.data.frame(read.csv(file = 'C:/Users/Juanjo/Desktop/MONCEF/house_king_county-Moncef/test_final.csv'))

```

En este apartado, hemos estimado varios modelos a partir de distintas metodologías para poder comparar cual de ellos nos arroja mejores resultados, esto es, menor error cuadratico medio. Para ello, se han estimado los siguientes modelos:

* Modelo con la variables respuesta "log_price_m2" : en este modelo utilizamos la variable respuesta dividida por los metros cuadrados con el objetivo de estabilizar la variable "price", variable con mucha dispersión.

* Modelo con la variables respuesta sugeridas por la regresión LASSO : en este modelo utilizamos de nuevo la variable respuesta dividida por los metros cuadrados, siendo las variables explicativas aquellas seleccionadas por la regresión LASSO.

* Modelo con la variables respuesta sugeridas por su capacidad de reducción del AIC : en este modelo utilizamos de nuevo la variable respuesta dividida por los metros cuadrados, siendo las variables explicativas aquellas que mayor aportación tienen en términos de reducción del AIC.


Para los dos modelos iniciales, la metodología de selección de variables ha sido similar a un proceso "backwards". Se han introducido todas las variables (previa limpiza de aquellas con mayor correlación entre si) y se ha estimado el modelo. Para aquellas variables que el modelo consideraba que no son significativas, estas son eliminadas y se estima un nuevo modelo. Este proceso se repite de forma recursiva hasta que todas las variables incluidas resulten significativas. 



```{r, include=FALSE}

#specify_decimal
specify_decimal <- function(x, k) format(round(x, k), nsmall=k)

#beautifying summary.lm
new_summary  <- function(lmcoef, digits) {
  
  coefs <- as.data.frame(lmcoef)
  coefs[] <- lapply(coefs, function(x) specify_decimal(x, digits))
  coefs
  
}


```



### Modelo con la variables respuesta "log_price_m2"

En este apartado estimamos un modelo con la variables respuesta "log_price_m2". Para este modelo utilizamos la variable respuesta dividida por los metros cuadrados con el objetivo de estabilizar la variable "price", la cual presenta una gran dispersión.



```{r}

train_v1 <- na.omit(train)
train_v1$sqft_basement_log = log(train_v1$sqft_basement)

#Incluimos en c() las variables que NO queremos usar en la regresiÃ³n.
train_v2 = dplyr::select(train,-c(sale_quarter_Q1,sale_quarter_Q4,floors, sale_quarter_Q3,price_m2,id,sale_tenure_log,yr_renovated,sqft_above,sqft_lot,sale_tenure,yr_renovated,sqft_living,Dist_from_seattle,price,date,zipcode,sqft_basement,lat,sqft_lot15,long,date,sale_date,sqft_above_log,sale_year,sale_month,yr_since_last_renovated,sqft_living15))


model <- lm(price_m2_log ~ . , data = train_v2)
summary(model)
new_summary(summary(model)$coefficients, 5)

plot(model, which=1, col=c("blue"))
plot(model, 2)

require(nortest)  # Se debe haber instalado nortest
lillie.test(model$residuals)


gvlma(model)
car::vif(model)

```


```{r}

#Test bondad del auste para los residuos del modelo con log_price_m2

require(nortest)  # Se debe haber instalado nortest
(lillie.test(model $residuals))


```

En este segundo modelo, podemos ver que el R2 ajustado es del 71%, 14% puntos mayor al modelo inicial. Por otra parte, el grafico de los residuos no muestra una tendencía como el modelo anterior y parece que los residuos fluctuan alrededor de la media, siendo la varianza relativamente constante.

No obstante, tanto el Q-Q plot como el test de bondad de ajuste realizado sobre los residuos nos hacen rechazar la hipótesis nula de normalidad de los residuos. 


```{r}
test_pred_model <- predict(model,newdata=test_final)

test_y   <- test_final$price_m2_log

SS.total      <- sum((test_y - mean(test_y))^2)
SS.residual   <- sum((test_y - test_pred_model)^2)
SS.regression <- sum((test_pred_model- mean(test_y))^2)
SS.total - (SS.regression+SS.residual)
# [1] 8958890

# NOT the fraction of variability explained by the model
test.rsq <- SS.residual/SS.total  
test.rsq
# [1] 0.0924713

# fraction of variability explained by the model
(r2 = SS.regression/SS.total) 
# [1] 0.08956405

```

Este modelo arroja un R2 del 70% en la base de datos "test".

### Modelo con la variables respuesta sugeridas por la regresión LASSO

Para este modelo utilizamos de nuevo la variable respuesta dividida por los metros cuadrados, siendo las variables explicativas aquellas seleccionadas por la regresión LASSO.


```{r, include=FALSE}

train_v2_nona <- na.omit(train_v2)

x <- model.matrix(log(train_v2_nona$price_m2)~., train_v2_nona )[,-1]
y <- log(train_v2_nona$price_m2)


lambdas <- model.matrix(price_m2_log ~., data = train_v2_nona)


```



```{r}

# Ajuste de la funciÃ³n de error
cv_lasso <- cv.glmnet(x = lambdas, y = y, alpha = 1)
plot(cv_lasso)


out_eleven <- glmnet(lambdas,y,alpha=1,lambda = cv_lasso$lambda.1se)
out_eleven
coef(out_eleven )
cv_lasso

```

Observamos que la regresión LASSO minimiza el error con 29 variables, si bien con 25 variables el error apenas incrementa. A partir de esta 25 variables propuestas por esta metodología, estimamos un nuevo modelo y realizamos un test de bondad del ajuste sobre sus residuos:


```{r}

# Test de normalidad de residuos
preds_lasso <- predict(out_eleven,lambdas)
residuals_lasso <- y - preds_lasso
lillie.test(residuals_lasso)

rsq_lasso <- cor(y, preds_lasso)^2
sprintf("R2 = %f", rsq_lasso)


```


Nuevamente rechzamos la hipótesis de normalidad de los residuos. Por otra parte el R2 de este modelo ha bajado en 1% respecto al modelo anterior, situandose en el 70.6%

Este modelo arroja un R2 del 66% en la base de datos "test".


### Modelo con la variables respuesta sugeridas por su capacidad de reducción del AIC

En este modelo utilizamos de nuevo la variable respuesta dividida por los metros cuadrados, siendo las variables explicativas aquellas que mayor aportación tienen en términos de reducción del AIC.

```{r}

#Analisis de variables candidatas 
step_model <- stepAIC(model, trace = TRUE, direction= "both")
#stargazer(model, step_model, type = "text")


```

Observamos que a partir de la variable "bedrooms", el aporte del resto de variables a la redución del AIC es mínimo. Estableciendo el humbral de forma arbitraria en 5.5, estimamos un nuevo modelo basado en en las variables que superan el umbral propuesto, siendo el número de variables de 18.


```{r}

train_v2 = dplyr::select(train,-c(price_m2,id,sale_tenure_log,yr_renovated,sqft_above,sqft_lot,sale_tenure,yr_renovated,sqft_living,Dist_from_seattle,price,date,zipcode,sqft_basement,lat,sqft_lot15,long,date,sale_date,sqft_above_log,sale_year,yr_built,sale_month,yr_since_last_renovated,sqft_living15))


model_AIC <- lm(price_m2_log ~ +sqft_living_log + grade + Clusters_1 + Clusters_4 + Clusters_5 + Dist_from_seattle_log + Clusters_11 
                + Clusters_8 + view + condition + waterfront_1 + Clusters_10 + Clusters_6 + floors + sale_quarter_Q3 + sale_quarter_Q4  
                  +bedrooms, data = train_v2)


summary(model_AIC)

summary(model_AIC)
new_summary(summary(model_AIC)$coefficients, 5)

plot(model_AIC, which=1, col=c("blue"))
plot(model_AIC, 2)
car::vif(model_AIC)
gvlma(model_AIC)



```

A la vista de los resultados, podemos observar que el R2 se situa en 70.23%, ligeramente inferior a los dos modelos anteriores, si bien el modelo se ha estimado con 7 variables menos, lo que nos permite concluir que estas 7 variable no aportan una gran capacidad explicativa al modelo.


```{r}

require(nortest)  # Se debe haber instalado nortest
lillie.test(model_AIC$residuals)


```


Este modelo arroja un R2 del 68.6% en la base de datos "test".


## Conclusiones

Las principales conclusiones han sido las siguientes:

* En análisis inicial no ha permitido conocer los datos y sus principales medidas. Asímismo, hemos podido crear nuevas variables que no han sido de gran utilidad a la hora de estimar algunos modelos.

*  Mediante el análisis multivariantes, donde hemos podido analizar tanto las variables entre si como las variables frente a la variable respuesta, se ha podido detrminar que variables nos ayudan a explicar mejor la variable respuesta, asi como aquellas vatriables a excluir para no incurrir en multicolinealidad. Por otra parte, algunas variables que mantenian una relación no lineal con las variable respuesta han sido transformadas para forzar una relación lineal. 

* En cuanto a los modelos, ninguno de ellos logra que los residuos sean ruido blanco, asi como evitar la heterocedasticidad. No obstante, el R2 observado para todos los modelos en la base de datos "test" es bueno, lo que indica que los modelos son estables a pesar de no cumplir las principales hipótesis de la regresión lineal.





